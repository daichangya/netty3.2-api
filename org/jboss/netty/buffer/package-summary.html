<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_22) on Fri Mar 11 12:01:01 CST 2011 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
org.jboss.netty.buffer
</TITLE>

<META NAME="date" CONTENT="2011-03-11">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.jboss.netty.buffer";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/jboss/netty/bootstrap/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/jboss/netty/channel/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/jboss/netty/buffer/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
软件包 org.jboss.netty.buffer
</H2>
一个字节缓冲的抽象  - 表现一个底层二进制和文本消息的基础数据结构.
<P>
<B>请参见：</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>描述</B></A>
<P>

<map id="APIVIZ" name="APIVIZ">
<area shape="rect" id="node1" href="BigEndianHeapChannelBuffer.html" title="BigEndianHeapChannelBuffer" alt="" coords="917,377,1107,405"/>
<area shape="rect" id="node2" href="ByteBufferBackedChannelBuffer.html" title="ByteBufferBackedChannelBuffer" alt="" coords="673,453,879,481"/>
<area shape="rect" id="node3" href="ChannelBufferInputStream.html" title="ChannelBufferInputStream" alt="" coords="463,123,633,151"/>
<area shape="rect" id="node4" href="ChannelBufferOutputStream.html" title="ChannelBufferOutputStream" alt="" coords="457,367,639,395"/>
<area shape="rect" id="node5" href="CompositeChannelBuffer.html" title="CompositeChannelBuffer" alt="" coords="695,503,857,531"/>
<area shape="rect" id="node6" href="DirectChannelBufferFactory.html" title="DirectChannelBufferFactory" alt="" coords="459,5,637,33"/>
<area shape="rect" id="node7" href="DuplicatedChannelBuffer.html" title="DuplicatedChannelBuffer" alt="" coords="695,285,857,313"/>
<area shape="rect" id="node8" href="DynamicChannelBuffer.html" title="DynamicChannelBuffer" alt="" coords="700,351,852,379"/>
<area shape="rect" id="node9" href="HeapChannelBufferFactory.html" title="HeapChannelBufferFactory" alt="" coords="460,55,636,83"/>
<area shape="rect" id="node10" href="LittleEndianHeapChannelBuffer.html" title="LittleEndianHeapChannelBuffer" alt="" coords="912,427,1112,455"/>
<area shape="rect" id="node11" href="ReadOnlyChannelBuffer.html" title="ReadOnlyChannelBuffer" alt="" coords="697,219,855,247"/>
<area shape="rect" id="node12" href="SlicedChannelBuffer.html" title="SlicedChannelBuffer" alt="" coords="707,161,845,189"/>
<area shape="rect" id="node13" href="TruncatedChannelBuffer.html" title="TruncatedChannelBuffer" alt="" coords="697,106,855,134"/>
<area shape="rect" id="node14" href="AbstractChannelBuffer.html" title="AbstractChannelBuffer" alt="" coords="471,317,625,345"/>
<area shape="rect" id="node15" href="AbstractChannelBufferFactory.html" title="AbstractChannelBufferFactory" alt="" coords="227,37,424,65"/>
<area shape="rect" id="node16" href="HeapChannelBuffer.html" title="HeapChannelBuffer" alt="" coords="709,402,843,430"/>
<area shape="rect" id="node17" href="ChannelBuffer.html" title="&#171;interface&#187; ChannelBuffer" alt="" coords="275,245,376,291"/>
<area shape="rect" id="node18" href="ChannelBufferFactory.html" title="&#171;interface&#187; ChannelBufferFactory" alt="" coords="5,28,152,73"/>
<area shape="rect" id="node19" href="ChannelBufferIndexFinder.html" title="&#171;interface&#187; ChannelBufferIndexFinder" alt="" coords="464,176,632,221"/>
<area shape="rect" id="node20" title="&#171;interface&#187; DataInput (java.io)" alt="" coords="283,103,368,166"/>
<area shape="rect" id="node21" title="&#171;interface&#187; DataOutput (java.io)" alt="" coords="281,350,369,413"/>
<area shape="rect" id="node22" href="WrappedChannelBuffer.html" title="&#171;interface&#187; WrappedChannelBuffer" alt="" coords="471,245,625,291"/>
<area shape="rect" id="node23" href="ChannelBuffers.html" title="&#171;static&#187; ChannelBuffers" alt="" coords="24,245,133,291"/>
</map>

<CENTER><IMG SRC="package-summary.png" USEMAP="#APIVIZ" BORDER="0"></CENTER>
<BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>接口摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口">ChannelBuffer</A></B></TD>
<TD>随机和顺序访问序列零个或多个字节.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBufferFactory.html" title="org.jboss.netty.buffer 中的接口">ChannelBufferFactory</A></B></TD>
<TD>创建和池化<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>的工厂.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBufferIndexFinder.html" title="org.jboss.netty.buffer 中的接口">ChannelBufferIndexFinder</A></B></TD>
<TD>定位数据在<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>中的索引.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/WrappedChannelBuffer.html" title="org.jboss.netty.buffer 中的接口">WrappedChannelBuffer</A></B></TD>
<TD>为缓冲包装和派生缓冲提供同一接口.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/AbstractChannelBuffer.html" title="org.jboss.netty.buffer 中的类">AbstractChannelBuffer</A></B></TD>
<TD>一个<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>的脚架实现.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/AbstractChannelBufferFactory.html" title="org.jboss.netty.buffer 中的类">AbstractChannelBufferFactory</A></B></TD>
<TD>一个<A HREF="../../../../org/jboss/netty/buffer/ChannelBufferFactory.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBufferFactory</CODE></A>的脚架实现.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/BigEndianHeapChannelBuffer.html" title="org.jboss.netty.buffer 中的类">BigEndianHeapChannelBuffer</A></B></TD>
<TD>一个big-endian的java堆缓冲.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.html" title="org.jboss.netty.buffer 中的类">ByteBufferBackedChannelBuffer</A></B></TD>
<TD>一个基于NIO <CODE>ByteBuffer</CODE>的缓冲.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBufferInputStream.html" title="org.jboss.netty.buffer 中的类">ChannelBufferInputStream</A></B></TD>
<TD>一个从<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>读取数据的<CODE>InputStream</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBufferOutputStream.html" title="org.jboss.netty.buffer 中的类">ChannelBufferOutputStream</A></B></TD>
<TD>一个用来写数据到一个<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>的<CODE>OutputStream</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ChannelBuffers.html" title="org.jboss.netty.buffer 中的类">ChannelBuffers</A></B></TD>
<TD>使用分配新空间或包装、拷贝已存在的字节数组、字节缓冲和字符串来创建一个新的<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/CompositeChannelBuffer.html" title="org.jboss.netty.buffer 中的类">CompositeChannelBuffer</A></B></TD>
<TD>显示多个缓冲成一个单一的合并缓冲的虚拟缓冲.强烈建议使用
 <A HREF="../../../../org/jboss/netty/buffer/ChannelBuffers.html#wrappedBuffer(org.jboss.netty.buffer.ChannelBuffer...)"><CODE>ChannelBuffers.wrappedBuffer(ChannelBuffer...)</CODE></A>代替直接调用构造方法.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/DirectChannelBufferFactory.html" title="org.jboss.netty.buffer 中的类">DirectChannelBufferFactory</A></B></TD>
<TD>为直接缓冲预分配一个大块和在需要时返回它的切片的<A HREF="../../../../org/jboss/netty/buffer/ChannelBufferFactory.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBufferFactory</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/DuplicatedChannelBuffer.html" title="org.jboss.netty.buffer 中的类">DuplicatedChannelBuffer</A></B></TD>
<TD>一个简单转发所有数据访问请求到父缓冲的派生缓冲.强烈建议使用<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html#duplicate()"><CODE>ChannelBuffer.duplicate()</CODE></A>代替调用构造方法.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/DynamicChannelBuffer.html" title="org.jboss.netty.buffer 中的类">DynamicChannelBuffer</A></B></TD>
<TD>一个能根据容量需求增加的动态容量缓冲.强烈建议使用<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffers.html#dynamicBuffer(int)"><CODE>ChannelBuffers.dynamicBuffer(int)</CODE></A>代替调用构造方法.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/HeapChannelBuffer.html" title="org.jboss.netty.buffer 中的类">HeapChannelBuffer</A></B></TD>
<TD>一个Java堆缓冲的脚架实现.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/HeapChannelBufferFactory.html" title="org.jboss.netty.buffer 中的类">HeapChannelBufferFactory</A></B></TD>
<TD>一个仅使用指定的容量分配一个堆缓冲的<A HREF="../../../../org/jboss/netty/buffer/ChannelBufferFactory.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBufferFactory</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.html" title="org.jboss.netty.buffer 中的类">LittleEndianHeapChannelBuffer</A></B></TD>
<TD>一个little-endian的java堆缓冲.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/ReadOnlyChannelBuffer.html" title="org.jboss.netty.buffer 中的类">ReadOnlyChannelBuffer</A></B></TD>
<TD>一个禁止任何对父缓冲写请求的派生缓冲.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/SlicedChannelBuffer.html" title="org.jboss.netty.buffer 中的类">SlicedChannelBuffer</A></B></TD>
<TD>一个只暴露父缓冲子部分的派生缓冲.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/jboss/netty/buffer/TruncatedChannelBuffer.html" title="org.jboss.netty.buffer 中的类">TruncatedChannelBuffer</A></B></TD>
<TD>一个隐藏父缓冲某个索引之后数据的派生缓冲.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
软件包 org.jboss.netty.buffer 的描述
</H2>

<P>
一个字节缓冲的抽象  - 表现一个底层二进制和文本消息的基础数据结构.

 Netty使用自己的缓冲API代替NIO<CODE>ByteBuffer</CODE>表示字节的序列.该方法比使用<CODE>ByteBuffer</CODE>有着显著的优势.Netty中的缓冲类型,
 <A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>被设计用来解决<CODE>ByteBuffer</CODE>的底层问题和解决网络应用程序开发者的日常需要.
 列出几个比较酷的特性:
 <ul>
   <li>你可以根据需要定义自己的缓冲类型.</li>
   <li>使用内置的组合缓冲类型实现透明零拷贝.</li>
   <li>一个容量可以按需扩展的动态缓冲类型随时可以被提供使用, 就像<CODE>StringBuffer</CODE>一样.</li>
   <li>不再需要调用<code>flip()</code>方法.</li>
   <li>比<CODE>ByteBuffer</CODE>更快.</li>
 </ul>

 <h3>扩展性</h3>

 <A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>为实现快速协议提供丰富的优化操作.比如,
 <A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>为访问无符号值和查找一个缓冲中指定的字节序列提供各种各样的操作.
 你也可以扩展或包装已有的缓冲类型,添加方便的存取.自定义缓冲类型总是实现
 <A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>接口而不是引入不兼容的类型.

 <h3>透明零拷贝</h3>

 为了尽量提高网络应用程序的性能,你需要减少内存拷贝操作的数量.你可能有一组被用来切割和合并组合成一个完整消息的缓冲.Netty提供
 一个允许不需要内存拷贝就可以把任意多个缓冲组合成一个新缓冲的组合缓冲.例如,一个消息一般由两部分组合而成:头部和消息体.在一个模块化的应用程序中,这两部分会在消息被发送时通过不同的模块被创建并组合.
 <pre>
 +--------+----------+
 | header |   body   |
 +--------+----------+
 </pre>
 如果使用<CODE>ByteBuffer</CODE>,你必须创建一个新的大的缓冲并拷贝这两部分到该缓冲中.另外,你可以使用NIO执行一个收集的写操作,但它会限制你使用一个组合缓冲作为
 <CODE>ByteBuffer</CODE>的数组,而不是一个单一缓冲,这样破坏了抽象和引入复杂的状态管理.而且,如果你不打算对一个NIO缓冲读或写时它一无是处.
 <pre>
 // 组合类型与组件类型不兼容.
 ByteBuffer[] message = new ByteBuffer[] { header, body };
 </pre>
 相比之下,<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>并没有这个警告,因为它是完全可扩展和具有内置的组合缓冲类型.
 <pre>
 // 组合类型与组件类型兼容.
 ChannelBuffer message = ChannelBuffers.wrappedBuffer(header, body);

 // 因此, 你甚至混合一个组合和一个原始缓冲来创建一个缓冲.
 ChannelBuffer messageWithFooter = ChannelBuffers.wrappedBuffer(message, footer);

 // 因为组合也是一个ChannelBuffer,所以你可以很容易的访问它的内容,而且即使你访问的区域超出多个组件,也可以像单一缓冲使用存取方法.这里跨越消息体和脚部的无符号整型会被获取.
 messageWithFooter.getUnsignedInt(
     messageWithFooter.readableBytes() - footer.readableBytes() - 1);
 </pre>

 <h3>自动容量扩展</h3>

大多协议会定义可变长度的消息,这意味着直到构造消息之前都没有任何办法检测消息的长度,或者很难、很不方便计算长度的精确值.这就像当你要建一个<CODE>String</CODE>.
 你会估算结果字符串的长度并让<CODE>StringBuffer</CODE>自动扩展.Netty允许你通过<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffers.html#dynamicBuffer()"><CODE>ChannelBuffers.dynamicBuffer()</CODE></A>创建的动态缓冲做相同的事情.
 <pre>
 // 创建一个动态缓冲.内部为了避免内存空间的消耗会延迟创建真实缓冲.
 ChannelBuffer b = ChannelBuffers.dynamicBuffer(4);

 // 当尝试第一次写,内部会创建一个指定初始容量为4的缓冲.
 b.writeByte('1');

 b.writeByte('2');
 b.writeByte('3');
 b.writeByte('4');

 // 当写入的字节超过初始容量4时,内部缓冲会自动重新分配一个更大的容量.
 b.writeByte('5');
 </pre>

 <h3>更好的性能</h3>

最常用<A HREF="../../../../org/jboss/netty/buffer/ChannelBuffer.html" title="org.jboss.netty.buffer 中的接口"><CODE>ChannelBuffer</CODE></A>的实现是一个很轻量的字节数组(如:byte[])包装
不像<CODE>ByteBuffer</CODE>, 它没有复杂的边缘检查和索引补偿,因此更容易的为JVM优化一个缓冲的访问.
 更复杂的缓冲仅用于切片或组合缓冲,以及<CODE>ByteBuffer</CODE>.
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/jboss/netty/bootstrap/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/jboss/netty/channel/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/jboss/netty/buffer/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
